# Задание 2: определение траектории частиц

Параллельная реализация симуляции движения N частиц с использованием OpenMP. Задание выполнено только на 1 балл, без CUDA.

## Реализованные алгоритмы

### 1. Метод Эйлера

Используется метод Эйлера первого порядка для обновления скоростей и позиций.

### 2. Параллелизация: OpenMP с динамическим планированием

a) **Вычисление сил в функции compute_forces**
#pragma omp parallel for schedule(dynamic) private(k, dx, dy, r, r3, force_x, force_y, tid)
for (q = 0; q < n; q++) {
    tid = omp_get_thread_num();
    for (k = q + 1; k < n; k++) {
        // Вычисление силы между телами q и k
        // Используется 3-й закон Ньютона: F_qk = -F_kq
    }
}

**Тип планирования:** schedule(dynamic) — динамическое распределение итераций.
**Локальные массивы сил:** Каждый поток записывает результаты в свой массив, избегая race conditions.
**Оптимизация:** Вычисление только для пар (q, k) где k > q.

b) **Обновление скоростей и позиций в функции update_velocities_and_positions:**
#pragma omp parallel for private(fx_total, fy_total, i)
for (q = 0; q < n; q++) {
    // Суммирование сил от всех потоков
    fx_total = 0.0;
    fy_total = 0.0;
    for (i = 0; i < num_threads; i++) {
        fx_total += fx_local[i][q];
        fy_total += fy_local[i][q];
    }
    // Обновление скорости и позиции
    bodies[q].vx += (fx_total / bodies[q].mass) * dt;
    bodies[q].vy += (fy_total / bodies[q].mass) * dt;
    bodies[q].x += bodies[q].vx * dt;
    bodies[q].y += bodies[q].vy * dt;
}

## Замеры производительности

- **Метод замера:** omp_get_wtime()
- **Что измерялось:** Полное время выполнения симуляции.
- **Аппаратная конфигурация: процессор AMD Ryzen 5 4500, 6 ядер.**

### Результаты:

### 1. Наглядная демонстрация результатов

Программа была запущена на файле input_2.txt, где прописаны параметры для 15-ти точек: масса, координаты x и y и две составляющие скорости. В результате был создан файл output.csv (находится в папке results), где просчитаны координаты x и y для каждых 0.01 секунды в промежутке от 0 до 20 секунд. 
Далее по получившимся координатам был создан график траекторий, где можно увидеть, что алгоритм корректно просчитывает координаты точек, так как видно их взаимодействие.

![График траекторий](results/trajectories.png)

### 2. Тестирование на большом количестве точек

Для подсчета времени выполнения, ускорения и эффективности, тестирование проводилось на файле input_1000.txt. Вывод времени выполнения в консоль можно увидеть в файле results_1000.txt в папке results. Формулы подсчета метрик, построение графиков можно увидеть в файле Метрики.csv в папке results.

![Таблица времени, ускорения и эффективности](results/table.PNG)

![График времени](results/exec.png)
![График ускорения](results/speedup.png)
![График эффективности](results/eff.png)

### Выводы

1. **Успешная параллелизация.**
Реализованная стратегия распараллеливания с использованием OpenMP продемонстрировала значительное ускорение для задачи моделирования 1000 тел. Время выполнения сократилось с 25 секунд до 10 секунд (на 6 потоках), что соответствует ускорению в 2.7 раза.​

Преимущества реализованного подхода:

- Локальные массивы сил для каждого потока (fx_local[tid][]) полностью устраняют race conditions.
- Динамическое планирование (schedule(dynamic)) обеспечивает эффективную балансировку нагрузки.
- Использование 3-го закона Ньютона (вычисление только для пар k>q) сокращает объем вычислений вдвое.

2. **Оптимальные результаты для 6-ядерного процессора.**

При 6 потоках (соответствует числу физических ядер) достигается:​

- Максимальное ускорение 2.7.
- Приемлемая эффективность 45%.
- Время выполнения примерно 9.3 секунд.

Дальнейшее увеличение числа потоков (8, 12) не дает прироста производительности — время остается на уровне 10 секунд.

