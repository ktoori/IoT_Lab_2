## Задание "Реализация блокировок чтения-записи "

### 1. Описание задачи
Целью работы являлась реализация собственного механизма блокировок чтения-записи с использованием мьютексов и условных переменных и сравнение его производительности со стандартной реализацией pthread_rwlock_t. Апробация проводилась на задаче параллельной обработки односвязного списка.

### 2. Описание реализации алгоритмов

#### 2.1. Структура данных my_rwlock_t
Для реализации механизма была разработана структура, содержащая:
- `mutex`: для обеспечения атомарного доступа к полям структуры
- `readers_ok` и `writers_ok`: условные переменные для ожидания читателей и писателей 
- `read_count`: счетчик активных читателей
- `write_count`: флаг активности писателя (0 или 1)
- `read_waiters`: счетчик ожидающих читателей
- `write_waiters`: счетчик ожидающих писателей

#### 2.2. Алгоритм 
Реализована стратегия с приоритетом писателей, чтобы избежать их голодания при интенсивном потоке читателей:

*   **`rdlock` (захват на чтение):**
    *   Поток ждет, если write_count > 0 (писатель работает) ИЛИ write_waiters > 0 (писатель ждет)
    *   После захвата увеличивает read_count

*   **`wrlock` (захват на запись):**
    *   Поток ждет, если read_count > 0 (есть читатели) ИЛИ write_count > 0 (другой писатель работает)
    *   После захвата устанавливает write_count = 1

*   **`unlock` (освобождение):**
    *   Если освобождает писатель: сбрасывает write_count и пробуждает всех (broadcast).
    *   Если освобождает читатель: уменьшает read_count. Если читателей не осталось (read_count == 0), посылает сигнал писателям

 ### 3. Результаты замеров производительности
 
 **Методика тестирования:**
- Среда: WSL, Компилятор: GCC 
- Измерение: Функция gettimeofday (через макрос GET_TIME). Время замерялось для полного цикла выполнения всех операций всеми потоками
- Метрика: Количество операций в секунду и общее время выполнения

Ниже приведена таблица сравнения собственной реализации (Custom) и стандартной библиотечной (Stdlib). Данные сгруппированы по количеству потоков.

| Потоки | Начальные элем. | Всего операций | % (Поиск/Вставка/Удал.) | Custom (ops/sec) | Stdlib (ops/sec) | Ускорение (Stdlib/Custom) |
|:---:|:---:|:---:|:---:|---:|---:|:---:|
| **1** | 100 | 10,000 | 80% / 10% / 10% | 590,564 | 360,385 | 0.61x (Custom быстрее) |
| **1** | 500 | 100,000 | 80% / 10% / 10% | 70,276 | 75,282 | 1.07x |
| **1** | 500 | 100,000 | 90% / 5% / 5% | 161,199 | 157,929 | 0.98x (Custom быстрее) |
| **1** | 500 | 100,000 | 33% / 33% / 33% | 7,447 | 6,002 | 0.81x (Custom быстрее) |
| **2** | 100 | 10,000 | 80% / 10% / 10% | 358,653 | 454,465 | 1.27x |
| **2** | 500 | 100,000 | 80% / 10% / 10% | 35,227 | 29,763 | 0.84x (Custom быстрее) |
| **2** | 500 | 100,000 | 90% / 5% / 5% | 31,930 | 63,498 | 1.99x |
| **2** | 500 | 100,000 | 33% / 33% / 33% | 5,710 | 4,739 | 0.83x (Custom быстрее) |
| **4** | 100 | 10,000 | 80% / 10% / 10% | 291,411 | 217,043 | 0.74x (Custom быстрее) |
| **4** | 500 | 100,000 | 80% / 10% / 10% | 26,062 | 36,800 | 1.41x |
| **4** | 500 | 100,000 | 90% / 5% / 5% | 69,057 | 76,261 | 1.10x |
| **4** | 500 | 100,000 | 33% / 33% / 33% | 3,947 | 6,354 | 1.61x |
| **8** | 100 | 10,000 | 80% / 10% / 10% | 54,641 | 170,146 | 3.11x |
| **8** | 500 | 100,000 | 80% / 10% / 10% | 17,843 | 18,015 | 1.01x (Практически равны) |
| **8** | 500 | 100,000 | 90% / 5% / 5% | 40,503 | 75,839 | 1.87x |
| **8** | 500 | 100,000 | 33% / 33% / 33% | 3,929 | 6,164 | 1.57x |

### 4. Анализ результатов

1.  **Однопоточный режим (1 поток):**
    *   Собственная реализация Custom в большинстве тестов работает быстрее стандартной. Это объясняется мьютексами и проверкой условий без системных вызовов ожидания, в отличие от универсальноц реализации pthread_rwlock_t

2.  **Малая нагрузка (2 потока):**
    *   Результаты смешанные. В сценариях с частыми чтениями (90%) стандартная библиотека оказывается в 2 раза быстрее. Однако в сценариях с интенсивной записью (33%) или на коротких списках Custom реализация все еще показывает лучшие результаты

3.  **Высокая нагрузка (4-8 потоков):**
    *   Стандартная библиотека (Stdlib) начинает стабильно показывать лучший результат, особенно на задачах с высоким процентом чтений (90%).
    *   На 8 потоках в коротком тесте (100 элементов) Stdlib быстрее более чем в 3 раза. Это демонстрирует эффективность реализации pthread_rwlock_t, которая лучше масштабируется при высокой конкуренции, чем реализация на базе pthread_cond_wait

### 5. Выводы
Разработанная реализация rwlock корректно функционирует и обеспечивает целостность данных. Она эффективна при малой конкуренции, но уступает библиотечной реализации pthread_rwlock_t при увеличении числа потоков, особенно из-за достаточных расходов на переключение контекста при использовании условных переменных. Тем не менее, она успешно реализует политику приоритета писателей, что гарантирует отсутствие "голодания" операций записи


